import os
import json # Added for RAG source formatting

from llama_index.core.tools import FunctionTool
from llama_index.readers.web import SimpleWebPageReader
from llama_index.readers.semanticscholar import SemanticScholarReader
from llama_index.tools.wikipedia import WikipediaToolSpec
from llama_index.tools.tavily_research import TavilyToolSpec
from llama_index.tools.duckduckgo import DuckDuckGoSearchToolSpec
from llama_index.core import VectorStoreIndex, StorageContext, load_index_from_storage
from llama_index.core import Settings
from llama_index.tools.code_interpreter import CodeInterpreterToolSpec
from huggingface_hub import HfFileSystem

# --- Hugging Face RAG Configuration ---
HF_DATASET_ID = "gm42/esi_simplevector"  # As used in make_rag.py
HF_VECTOR_STORE_SUBDIR = "vector_store_data" # As used in make_rag.py

# Determine project root based on the script's location
# For tools.py directly in the 'esi' project root, PROJECT_ROOT is the directory of tools.py
PROJECT_ROOT = os.path.abspath(os.path.dirname(__file__))

# Ensure API keys are set as environment variables
# os.environ["TAVILY_API_KEY"] = "YOUR_TAVILY_API_KEY"
# os.environ["GOOGLE_API_KEY"] = "YOUR_GOOGLE_API_KEY"

# Directory where files generated by code interpreter should be accessible by the UI
# Define it relative to the project root
UI_ACCESSIBLE_WORKSPACE_RELATIVE = "./code_interpreter_ws"
UI_ACCESSIBLE_WORKSPACE = os.path.join(PROJECT_ROOT, UI_ACCESSIBLE_WORKSPACE_RELATIVE)
os.makedirs(UI_ACCESSIBLE_WORKSPACE, exist_ok=True)


# --- Individual Tool Initializations ---

def get_duckduckgo_tool():
    """Initializes the DuckDuckGo search tool."""
    try:
        return DuckDuckGoSearchToolSpec().to_tool_list()[0]
    except NameError:
        print("Error: DuckDuckGoSearchToolSpec not found. Trying DuckDuckGoToolSpec.")
        try:
            from llama_index.tools.duckduckgo import DuckDuckGoToolSpec
            return DuckDuckGoToolSpec().to_tool_list()[0]
        except Exception as e_fallback:
            print(f"Error initializing DuckDuckGo Tool (fallback failed): {e_fallback}")
            return None
    except Exception as e:
        print(f"Error initializing DuckDuckGo Tool: {e}")
        return None

def get_tavily_tool():
    """Initializes the Tavily search tool."""
    tavily_api_key = os.getenv("TAVILY_API_KEY")
    if not tavily_api_key:
        print("Warning: TAVILY_API_KEY not found in environment variables.")
        return None
    try:
        return TavilyToolSpec(api_key=tavily_api_key).to_tool_list()[0]
    except Exception as e:
        print(f"Error initializing Tavily Tool: {e}")
        return None

def get_wikipedia_tool():
    """Initializes the Wikipedia tool."""
    try:
        return WikipediaToolSpec().to_tool_list()[0]
    except Exception as e:
        print(f"Error initializing Wikipedia Tool: {e}")
        return None

def get_semantic_scholar_tool_for_agent():
    """
    Initializes the Semantic Scholar tool.
    Returns a list containing the tool, suitable for an agent.
    """
    try:
        ss_reader = SemanticScholarReader()
        tool = FunctionTool.from_defaults(
            fn=lambda query: ss_reader.load_data(query=query, limit=5), # Load 5 papers
            name="semantic_scholar_search",
            description="Searches Semantic Scholar for academic papers based on a query.",
        )
        return [tool] if tool else []
    except Exception as e:
        print(f"Error initializing Semantic Scholar Tool: {e}")
        return []

def get_web_scraper_tool_for_agent():
    """
    Initializes the Web Scraper tool.
    Returns a list containing the tool, suitable for an agent.
    """
    try:
        # SimpleWebPageReader can handle HTML and attempt to load PDFs from URLs
        loader = SimpleWebPageReader(html_to_text=True) # html_to_text for cleaner HTML scraping
        tool = FunctionTool.from_defaults(
            fn=lambda url: loader.load_data(urls=[url]),
            name="web_scraper",
            description="Scrapes textual content from a given URL. This can be an HTML webpage or a direct link to a PDF document. Expects a single URL as input.",
        )
        return [tool] if tool else []
    except Exception as e:
        print(f"Error initializing Web Scraper Tool: {e}")
        return []

def get_rag_tool_for_agent():
    """Initializes the RAG query tool by loading the SimpleVectorStore from Hugging Face Hub."""
    
    hf_persist_path = f"datasets/{HF_DATASET_ID}/{HF_VECTOR_STORE_SUBDIR}"
    print(f"Attempting to load RAG index from Hugging Face Hub: {hf_persist_path}")

    try:
        # Initialize HfFileSystem
        hf_token = os.getenv("HF_TOKEN")
        if not hf_token:
            print("Warning: HF_TOKEN environment variable not set. Make sure you are logged in via `huggingface-cli login` or have set HF_TOKEN for read access to the Hugging Face Dataset.")
        
        hf_fs = HfFileSystem(token=hf_token)

        # Ensure Settings.embed_model and Settings.llm are set globally before this
        if not Settings.embed_model:
            print("Error: Settings.embed_model not configured. Cannot load RAG index.")
            raise ValueError("Settings.embed_model is not set.")
        if not Settings.llm:
            print("Error: Settings.llm not configured. Cannot create RAG query engine.")
            raise ValueError("Settings.llm is not set.")

        print("Loading index from Hugging Face storage...")
        # StorageContext will use HfFileSystem to access the specified path
        storage_context = StorageContext.from_defaults(persist_dir=hf_persist_path, fs=hf_fs)
        
        # SimpleVectorStore is loaded automatically within the storage context
        # We need the embed_model to potentially reconstruct parts of the index if needed by LlamaIndex
        index = load_index_from_storage(storage_context, embed_model=Settings.embed_model)
        print(f"Successfully loaded index from Hugging Face Hub: {hf_persist_path}")

        # Create a query engine from the loaded index
        # Ensure Settings.llm is set globally
        query_engine = index.as_query_engine(llm=Settings.llm)
        print("RAG query engine created.")

        # Define a simple function to wrap the query engine call
        def execute_rag_query(input: str):
                 """Executes a query against the RAG engine and returns the text response."""
                 try:
                     response_obj = query_engine.query(input)
                     text_response = str(response_obj.response) # The LLM-generated text summary

                     sources_info_parts = []
                     citation_counter = 1
                     assigned_pdf_citations = {} # Maps file_path to citation_number for uniqueness within this call

                     if response_obj.source_nodes:
                         for source_node in response_obj.source_nodes:
                             metadata = source_node.node.metadata
                             node_text_snippet = source_node.node.get_text()[:100] # For context

                             if 'file_path' in metadata:
                                 file_path = metadata['file_path']
                                 file_name = os.path.basename(file_path)
                                 
                                 current_citation_number = None
                                 if file_path not in assigned_pdf_citations:
                                     assigned_pdf_citations[file_path] = citation_counter
                                     current_citation_number = citation_counter
                                     citation_counter += 1
                                 else:
                                     current_citation_number = assigned_pdf_citations[file_path]
                                 
                                 source_data = {
                                     "type": "pdf", 
                                     "name": file_name, 
                                     "path": file_path, 
                                     "snippet": node_text_snippet + "...",
                                     "citation_number": current_citation_number # Add citation number
                                 }
                                 sources_info_parts.append(f"---RAG_SOURCE---{json.dumps(source_data)}")
                             elif 'url' in metadata: # Check for 'url' for web sources
                                 url = metadata['url']
                                 title = metadata.get('title', url) # Use title if available, else URL
                                 source_data = {"type": "web", "url": url, "title": title, "snippet": node_text_snippet + "..."}
                                 sources_info_parts.append(f"---RAG_SOURCE---{json.dumps(source_data)}")

                     # Append source markers to the text response
                     if sources_info_parts:
                         return text_response + "\n" + "\n".join(sources_info_parts)
                     else:
                         return text_response

                 except Exception as e:
                     print(f"Error during RAG query execution: {e}")
                     return f"Error querying the knowledge base: {e}"

        # Wrap the simple function with FunctionTool
        return FunctionTool.from_defaults(
                 fn=execute_rag_query,
                 name="rag_dissertation_retriever",
                 description=(
                    f"Retrieves relevant information from the dissertation knowledge base (persisted on Hugging Face at '{HF_DATASET_ID}/{HF_VECTOR_STORE_SUBDIR}'). "
                    "Use this for specific institutional knowledge or previously saved research. "
                    "The tool's output will include the textual answer and may be followed by structured references "
                    "(e.g., to PDF files or web URLs) using '---RAG_SOURCE---' markers. "
                    "For PDF sources, the structured reference will include a 'citation_number'. "
                    "When you use information from a PDF source in your response, you MUST append its citation number "
                    "in brackets (e.g., '[1]', '[2]') to the relevant sentence or claim. "
                    "The query to the knowledge base should be provided as the 'input' string argument."
                 ),
             )

    except Exception as e:
        error_message = f"Error initializing or loading RAG tool from Hugging Face ({HF_DATASET_ID}/{HF_VECTOR_STORE_SUBDIR}): {e}"
        print(error_message)
        # Return a dummy tool in case of loading error
        # Capture the error message in the lambda's default argument
        return FunctionTool.from_defaults(
            fn=lambda *args, msg=error_message, **kwargs: msg,
            name="rag_dissertation_retriever",
            description=f"The dissertation knowledge base (from Hugging Face: {HF_DATASET_ID}/{HF_VECTOR_STORE_SUBDIR}) is currently unavailable due to an error during initialization."
        )


# --- Tool Collections for Specialized Agents ---

def get_search_tools():
    """Initializes and returns a list of search-related tools."""
    tools = []
    ddg_tool = get_duckduckgo_tool()
    tavily_tool = get_tavily_tool()
    wiki_tool = get_wikipedia_tool()

    if ddg_tool: tools.append(ddg_tool)
    if tavily_tool: tools.append(tavily_tool)
    if wiki_tool: tools.append(wiki_tool)
    
    print(f"Initialized {len(tools)} search tools.")
    return tools

# --- Code Interpreter Tool Setup ---

def get_coder_tools():
    """
    Initializes the Code Interpreter tool, configured to use the shared workspace.
    Returns the original tool spec's tool list.
    """
    try:
        # Initialize CodeInterpreterToolSpec
        code_spec = CodeInterpreterToolSpec()

        # Attempt to set the work_dir of the underlying code_interpreter
        if hasattr(code_spec, 'code_interpreter') and code_spec.code_interpreter is not None:
            if hasattr(code_spec.code_interpreter, 'work_dir'):
                print(f"Attempting to set work_dir for code_interpreter to: {UI_ACCESSIBLE_WORKSPACE}")
                code_spec.code_interpreter.work_dir = UI_ACCESSIBLE_WORKSPACE
                # Verify if it was set (for debugging)
                print(f"Code interpreter work_dir is now: {getattr(code_spec.code_interpreter, 'work_dir', 'N/A')}")
            else:
                print("Warning: code_spec.code_interpreter does not have a 'work_dir' attribute.")
        else:
            print("Warning: code_spec.code_interpreter is not available. Cannot set work_dir. Files may be saved to a temporary location.")

        original_tools = code_spec.to_tool_list()

        if not original_tools:
            print("Warning: CodeInterpreterToolSpec returned no tools.")
            return []

        print(f"Initialized Code Interpreter Tool(s) for Coder Agent: {[t.metadata.name for t in original_tools]}")
        return original_tools

    except Exception as e:
        print(f"Error initializing Code Interpreter Tool for Coder Agent: {e}. Code execution will be unavailable.")
        return []

def get_all_tools():
    """
    Collects all available tools from the various getter functions.
    Returns a flat list of tools.
    """
    all_tools = []

    # 1. Search tools
    search_tools = get_search_tools()
    if search_tools:
        all_tools.extend(search_tools)

    # 2. Semantic Scholar tool
    semantic_scholar_tools = get_semantic_scholar_tool_for_agent()
    if semantic_scholar_tools:
        all_tools.extend(semantic_scholar_tools)

    # 3. Web Scraper tool
    web_scraper_tools = get_web_scraper_tool_for_agent()
    if web_scraper_tools:
        all_tools.extend(web_scraper_tools)

    # 4. RAG tool
    rag_tool = get_rag_tool_for_agent()
    if rag_tool:
        all_tools.append(rag_tool)

    # 5. Coder tools
    coder_tools = get_coder_tools()
    if coder_tools:
        all_tools.extend(coder_tools)

    # 8. Print collected tool names
    tool_names = [
        tool.metadata.name 
        for tool in all_tools 
        if hasattr(tool, 'metadata') and hasattr(tool.metadata, 'name')
    ]
    print(f"Collected tools: {tool_names}")

    return all_tools
